HyperactiveResource
===================

v0.2

Many have said that ActiveResource is not really "complete". On the surface,
this means that many standard ActiveRecord features are not implemented.

This makes the concept of swapping ActiveRecord for ActiveResource immensely
difficult (and cludgy, hand-built, buggy etc etc)

Arguably, a "complete" ActiveResource would behave like ActiveRecord or, as the
rdoc for ActiveResource states "very similarly to Active Record".

Hyperactive Resource is an extension to ActiveResource::Base and goes a long
way towards the goal of an ActiveResource that behaves like ActiveRecord.
It will slowly be updated with all the standard features of ActiveRecord
until (someday) it can be used almost interchangeably.

This code could indeed go directly into ActiveResource, but, given some fo
the implementations) that would put a dependancy between the two which may
be resolved once Rails 3.0 comes out. There's nothing stopping this code
from being integrated back into ARes at a later date :)

Features that Hyperactive Resource has added:
 * Client side validations (validates_uniqueness_of is still experimental!)
 * Hooks for before_validate, before_save
 * Dynamic finders: find_by_X find_all_by_X, find_first_by_X, find_last_by_X
 * save! / update_attributes!   (raises HyperactiveResource::ResourceNotSaved on failure)
 * ModelName.count (still experimental) - with optional finder-args
    - override the default counter_path with your own (see example below)
 * updated collection_path that allows suffix_options as well as
   prefix_options = allows us to generate Rails-style named routes
 * no explosion for delete_all/destroy_all on a 404
 * Awareness of associations between resources: belongs_to, has_many, has_one & columns
   * Patient.new.name returns nil instead of MethodMissing
   * Patient.new.races returns [] instead of MethodMissing
   * pat = Patient.new; pat.gender_id = 1; pat.gender #Will return find the gender obj
 * Resources can be associated with records
 * Records can be associated with records
 * ActiveRecord-like attributes= (updates rather than replaces)
 * ActiveRecord-like #load that doesn't #dup attributes (stores direct reference)
 * Supports saving resources that :include other resources via:
   * Nested resource saving (creating a patient will create their associated addresses)
   * Mapping associations ([:gender].id will serialize as :gender_id)

Example
=======

 1. Install the plugin via:

    cd path/to/rails_root/vendor/plugins
    git clone	git://github.com/taryneast/hyperactiveresource.git

 2. Create a HyperactiveResource where you would normally use ActiveResource
    and define the meta-data/associations that drive the dynamic magic:

    class Address < HyperactiveResource
      self.site = 'http://localhost:3001/'
      self.columns = [ :street_address, :city, :postcode, :phone, :email]
      self.belong_tos = [ :country, :state ]
      self.has_manys = [ :people ]
      self.counter_path = 'address_count.xml' # override default count path

      validates_presence_of :postcode, :phone
      validates_uniqueness_of :email
    end

 3. Enjoy the magic

    Address.delete_all # should not raise a 404
    Address.count # returns 0

    bad_address = Address.new
    bad_address.save! # raises ActiveResource::RecordNotSaved

    Address.count # returns 0

    address = Address.new(:postcode => '12345', :phone => '555 1234')
    address.country # nil instead of method_missing
    address.country_id = 5
    address.country  # Returns Country.find(5)
    address.save!    # returns true

    Address.first.phone # should return '555 1234'

    Address.count # returns 1
    Address.count(:phone => '555 9876') # returns 0

    bad_address = Address.create()
    bad_address.errors.full_messages.inspect # => "[\"Postcode can't be blank\", \"Phone can't be blank\"]"


    Address.count(:phone => '555 1234') # returns 1
  etc..

TODOs
=====

0) Testing!

1) ability to use ActiveRecord-style nomenclature for associations eg:
    has_many :x, :y, :z
  instead of: 
    self.has_manys = [:x, :y, :z]

2) proper callbacks for before/after save/create/validate etc rather than
  bodgied-up functions called directly in the code

3) conditional finders (eg MyModel.find(:all, :conditions => {:state =>
'active'} (partly works, but experimental - depends on your API accepting
params)

4) MyModel.with_scope

5) find(:include => ...)

6) attr_protected/attr_accessible

7) MyModel.calculate/average/minimum/maximum etc


N) merge of this stuff back into the real ActiveResource


Copyright and Authorship
=========

Author: Taryn East
Copyright (c) 2009 White Label Dating
http://whitelabeldating.com/

Based on Work Done by Medical Decision Logic

Original copyright:
Copyright (c) 2008 Medical Decision Logic
Released under the MIT license (see attached file)
